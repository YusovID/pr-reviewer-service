# Сервис назначения ревьюеров для Pull Request’ов

[![Go Version](https://img.shields.io/badge/Go-1.25.4-blue.svg)](https://golang.org/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Linter: golangci-lint](https://img.shields.io/badge/linter-golangci--lint-green.svg)](https://golangci-lint.run/)

Сервис для автоматического назначения ревьюеров на Pull Request'ы, управления командами и пользователями. Реализован в качестве тестового задания для стажировки Backend в Avito (осень 2025).

## Функционал

-   **Управление командами**: Создание команд и гибкое управление составом участников (добавление/обновление).
-   **Управление пользователями**: Изменение статуса активности пользователя (`isActive`).
-   **Жизненный цикл PR**: Создание Pull Request'а с автоматическим назначением до двух ревьюеров из команды автора.
-   **Идемпотентное слияние PR**: Возможность пометить PR как `MERGED`. Повторные вызовы не вызывают ошибок.
-   **Переназначение ревьюеров**: Замена одного ревьюера на случайного активного участника из его же команды.
-   **Получение данных**:
    -   Получение списка PR, назначенных конкретному пользователю.
    -   Получение информации о команде и ее участниках.
-   **Дополнительные возможности**:
    -   **Статистика**: Эндпоинт для получения статистики по количеству открытых и смерженных ревью для каждого пользователя.
    -   **Массовая деактивация**: API для деактивации всех участников команды с безопасным переназначением их открытых ревью.

## Технологический стек

-   **Язык**: Go 1.25.4
-   **База данных**: PostgreSQL 17
-   **API и роутинг**: `chi` v5, `oapi-codegen` для генерации кода из OpenAPI спецификации.
-   **Взаимодействие с БД**: `sqlx` для удобной работы с SQL, `squirrel` для построения запросов, `golang-migrate` для управления миграциями.
-   **Контейнеризация**: Docker, Docker Compose.
-   **Тестирование**:
    -   Unit-тесты: Стандартная библиотека, `stretchr/testify`.
    -   Интеграционные тесты: `testcontainers-go` для запуска PostgreSQL в Docker.
-   **Конфигурация**: `cleanenv` для загрузки конфигурации из YAML и переменных окружения.
-   **Логирование**: Стандартный пакет `log/slog` с кастомным "pretty" хендлером для локальной разработки.
-   **Линтинг**: `golangci-lint` с кастомной конфигурацией.
-   **Нагрузочное тестирование**: k6 (Grafana).

## Архитектура

Проект построен с использованием принципов **Clean Architecture** для четкого разделения ответственностей.

-   `cmd/`: Точки входа в приложение (основной сервис и утилита для миграций).
-   `internal/transport/http/`: Слой HTTP. Отвечает за прием запросов, их декодирование, вызов методов сервисного слоя и отправку ответов. Не содержит бизнес-логики.
-   `internal/service/`: Сервисный слой (Use Cases). Здесь инкапсулирована вся бизнес-логика. Он не зависит от деталей транспорта или базы данных.
-   `internal/repository/`: Слой репозитория. Определяет интерфейсы для работы с хранилищем данных и содержит их конкретную реализацию для PostgreSQL.
-   `internal/domain/`: Доменный слой. Содержит основные бизнес-сущности проекта.

Для разделения операций чтения и записи в репозиториях применен подход, близкий к **CQRS (Command Query Responsibility Segregation)**. Например, интерфейс для работы с Pull Request'ами разделен на `PRQueryRepository` (для чтения) и `PRCommandRepository` (для записи и блокировок).

## Запуск проекта

### Требования

-   Docker
-   Docker Compose
-   GNU Make
-   Go 1.25+

### Инструкция по запуску

1.  **Клонируйте репозиторий:**
    ```bash
    git clone https://github.com/YusovID/pr-reviewer-service
    cd pr-reviewer-service
    ```

2.  **Настройте окружение:**
    Скопируйте файл с переменными окружения:
    ```bash
    cp .env.example .env
    ```
    В файле `.env` уже содержатся все необходимые значения для запуска в Docker.

3.  **Запустите сервисы:**
    Выполните команду в корне проекта:
    ```bash
    make up
    ```
Эта команда соберет Docker-образы, поднимет контейнеры с приложением и базой данных, а также автоматически применит миграции.

Сервис будет доступен по адресу `http://localhost:8080`.

## Конфигурация

Сервис настраивается с помощью файла `config/local.yml` и переменных окружения.

-   **`config/local.yml`**: Основной файл конфигурации. Содержит настройки сервера, логирования и пула соединений с БД.
-   **`.env`**: Файл для секретов и переменных окружения (логин/пароль от БД, хост). Значения из этого файла переопределяют значения из `yml`-файла, если имена совпадают.

### Основные параметры

| Параметр                | Описание                                                                  | Значение по умолчанию |
| ----------------------- | ------------------------------------------------------------------------- | --------------------- |
| `server.host`           | Хост, на котором запускается сервис.                                      | `0.0.0.0`             |
| `server.port`           | Порт, на котором запускается сервис.                                      | `8080`                |
| `server.timeout`        | Таймаут на чтение и запись HTTP-запросов.                                 | `4s`                  |
| `env`                   | Среда выполнения (`local`, `dev`, `prod`). Влияет на формат логирования. | `local`               |

### Параметры пула соединений с БД

Эти параметры находятся в секции `postgres` файла `config/local.yml` и критически важны для производительности под нагрузкой.

| Параметр                   | Описание                                                              | Значение по умолчанию |
| -------------------------- | --------------------------------------------------------------------- | --------------------- |
| `max_open_conns`           | Максимальное количество открытых соединений с БД.                     | `20`                  |
| `max_idle_conns`           | Максимальное количество "простаивающих" соединений в пуле.            | `10`                  |
| `conn_max_lifetime`        | Максимальное время жизни одного соединения.                           | `5m`                  |
| `conn_max_idle_time`       | Максимальное время, которое соединение может простаивать в пуле.       | `1m`                  |

## Использование

### API Документация

Интерактивная документация API (Swagger UI) доступна после запуска сервиса по адресу:
[**http://localhost:8080/swagger**](http://localhost:8080/swagger)

### Основные эндпоинты

-   `POST /team/add`: Создать команду с участниками.
-   `GET /team/get`: Получить информацию о команде.
-   `POST /users/setIsActive`: Установить статус активности пользователя.
-   `POST /pullRequest/create`: Создать Pull Request.
-   `POST /pullRequest/merge`: Пометить PR как "смерженный".
-   `POST /pullRequest/reassign`: Переназначить ревьюера.
-   `GET /users/getReview`: Получить PR, назначенные пользователю.
-   `GET /stats`: Получить статистику по ревью.
-   `POST /team/deactivate`: Массово деактивировать команду.

## Разработка и тестирование

В проекте используется `Makefile` для автоматизации основных задач.

### Основные команды

-   `make help`: Показать список всех доступных команд.
-   `make up`: Запустить все сервисы в Docker.
-   `make down`: Остановить и удалить контейнеры.
-   `make nuke`: **Внимание!** Полностью остановить и удалить контейнеры, сети и **тома с данными**.
-   `make logs`: Показать логи запущенных сервисов.
-   `make lint`: Запустить `golangci-lint` для проверки кода.
-   `make test`: Запустить только unit-тесты (быстро).
-   `make test-integration`: Запустить интеграционные тесты (требуется Docker).
-   `make test-cover`: Запустить все тесты и сгенерировать отчет о покрытии в `coverage.html`.
-   `make test-load`: Запустить нагрузочное тестирование с помощью k6.

## Принятые решения и допущения

В ходе разработки были приняты следующие решения для улучшения качества и надежности кода:

1.  **Валидация идентификаторов в OpenAPI:** Исходная спецификация не содержала строгих ограничений для идентификаторов (`user_id`, `pull_request_id`). Я добавил `pattern: '^[a-zA-Z0-9_-]+$'` и ограничения по длине, чтобы обеспечить корректность и безопасность данных на уровне API-контракта.
2.  **Целостность данных в БД:**
    -   При удалении команды из таблицы `teams`, поле `team_id` у связанных пользователей в таблице `users` устанавливается в `NULL` (`ON DELETE SET NULL`). Это позволяет сохранить пользователей в системе даже после расформирования команды.
    -   При удалении Pull Request'а или пользователя, связанные записи в таблице `reviewers` удаляются каскадно (`ON DELETE CASCADE`), так как они теряют свой смысл.
3.  **Обработка гонок данных (Race Conditions):** Для критически важных операций, таких как слияние PR или переназначение ревьюера, используется пессимистическая блокировка `FOR UPDATE` на уровне SQL-запросов. Это гарантирует, что две одновременные операции не смогут привести к несогласованному состоянию данных.
4.  **Upsert для участников команды:** При добавлении/обновлении команды используется конструкция `ON CONFLICT DO UPDATE`, что позволяет одной операцией создавать новых пользователей и обновлять данные существующих (например, переводить их в новую команду). Это атомарно и эффективно.

## Результаты нагрузочного тестирования

Было проведено нагрузочное тестирование с помощью **k6**. Сценарий эмулировал основной поток использования сервиса: создание команды, создание PR и получение списка ревью.

-   **Интенсивность**: 5 итераций в секунду в течение 30 секунд.
-   **Максимальное количество виртуальных пользователей (VUs)**: 50.

**Ключевые результаты:**

| Метрика                      | Результат     | Порог      | Статус  |
| ---------------------------- | ------------- | ---------- | ------- |
| **p(95) http_req_duration**  | `15.24ms`     | `< 300ms`  | ✅ **PASS** |
| **http_req_failed**          | `0.00%`       | `< 1%`     | ✅ **PASS** |

Сервис успешно выдержал нагрузку, показав время ответа значительно ниже требуемого SLI (300 мс) и нулевой процент ошибок.
